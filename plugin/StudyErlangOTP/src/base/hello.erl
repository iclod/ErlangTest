-module(hello).
-compile(export_all).
-export([test2/1]).
-export ([test1/2]).
-export ([test3/1]).
%	******************************************************************************
%	------------------------------------------------------------------------------
%	习题 2
%		{5,1,8,7,3,9,2,6,4}元组内的数字依次乘以自己的下标位
%		结果：{5*1,1*2,8*3,7*4,3*5,9*6,2*7,6*8,4*9}
%	------------------------------------------------------------------------------
test2( {} )	->
	{}; 
test2( T ) when is_tuple(T) 	->
	test2a( [],1,tuple_to_list(T) ).

test2a( Res, _, [] )				->
	list_to_tuple( lists:reverse(Res) );
test2a( Res, Sub, [Ele|Rem] )		->
	test2a( [Sub*Ele|Res], Sub+1, Rem ).

%	******************************************************************************
%	------------------------------------------------------------------------------
%	习题 1
%	 	合并列表，A=[{a,1},{b,2},{c,3},{b,1}],B=[{b,4},{c,5},{d,6},{d,2}].
%			结果：[{a,1},{b,7},{c,8},{d,8}]
%		D=[{a,3},{f,14},{k,39},{f,22},{g,88},{d,23}].
%	------------------------------------------------------------------------------
test1( A, B )	->
	M = test1c( [], A ),
	test1c( M, B ).
%	对待定列表的单个元素进行操作，看是否是值相加后保存还是直接插入到结构列表里
%	 这里需要一个中间列表用于保存
test1b( R, {Nam,Val}, [{NamT,ValT}|T] )	when Nam =:= NamT ->
	R ++ [ {Nam, Val+ValT} | T ] ;
test1b( R, {Nam,Val}, [{NamT,ValT}|T] )	when Nam =/= NamT ->
	test1b( R++[{NamT,ValT}], {Nam,Val}, T );
test1b( R, E, [] )	->
	R ++ [E].

%	对待定列表每个元素进行test1b单元素操作处理
test1c(  R, [Ah|A] )	->
	M = test1b( [], Ah, R ),
	test1c( M, A );
test1c( R, [] )	->
	R.

%	******************************************************************************
%	---------------------------------------------------------------------------------
%	习题 3
%		排序[{"a",5},{"b",1},{"c",8},{"d",7},{"e",3},{"f",9},{"g",2},{"h",6},{"i",4}] 
%       禁用API(例如lists:sort,lists:usort等)
%		结果：[{"a",1},{"b",2},{"c",3},{"d",4},{"e",5},{"f",6},{"g",7},{"h",8},{"i",9}]
%	---------------------------------------------------------------------------------

test3( A )	->	test3a(A).

less( {_,KeyA}, {_,KeyB} ) 	->
	case KeyA < KeyB of
		true 	->	true;
		false	->	false
	end
.

test3a( [Ah|A] )	->
	test3a( [ X || X<-A, less(X,Ah) ] )	++
	[Ah]++
	test3a( [ X || X<-A, less(Ah,X) ] );
test3a( [] )		->
	[]
.





